set cut_paste_input [stack 0]
version 9.0 v7
push $cut_paste_input
Group {
name N_AmbientLight1
tile_color 0xbcab3bff
addUserKnob {20 m_ambientLight l M_AmbientLight}
addUserKnob {22 Compute_Coefficients l " Compute Coefficients " T "from nukescripts import cache_clear\ncache_clear(\"\")\n\nimport math\nPI = math.pi\n\nmyClose=0\n\ndef sinc(x):\n    if (math.fabs(x) < 0.0001):\n        return 1.0\n    else :\n        return(math.sin(x)/x)   # supporting sinc function\n\ncoeffs=\[\[0 for COL in range(3)] for L in range(9)]\nw=0\ni=0\nj=0\nk=0\np=0\nu=0\nv=0\n\n# check if probe is a square angular map.\n\nmyNode= nuke.thisNode()\nfor t in myNode.nodes() :\n    if t.name() == 'LightProbe':\n        tmpW = int(nuke.value(t.name()+\".format.w\"))\n        tmpH = int(nuke.value(t.name()+\".format.h\"))\n        if tmpW!=tmpH:\n            nuke.message('The HDR map you are using is not in the right format. Please use a square angular map.')\n            myClose=1\n\nfor a in myNode.nodes() :\n    if a.name() == 'Reformat_IBL':\n        sn = a\n\nw = int(nuke.value(sn.name()+\".format.w\"))    #get probe width\n\nhdr = \[\[\[0 for COL in range(3)] for Y in range(w)] for X in range(w)]\n\nfor i in range(w):\n    if myClose == 1:\n        break   #if probe isn't square stop\n    for j in range (w):\n\n        hdr\[i]\[j]\[0]= sn.sample(\"r\", i, j)   #sample probe and fill hdr array\n        hdr\[i]\[j]\[1]= sn.sample(\"g\", i, j)\n        hdr\[i]\[j]\[2]= sn.sample(\"b\", i, j)\n\n# The prefiltering routine\n\nfor k in range (w):\n    if myClose == 1:\n        break   #if probe isn't square stop\n    for p in range (w):\n        # find the cartesian components for the point (i,j)\n\n        v = (w/2.0 - k)/(w/2.0)   # v ranges from -1 to 1\n        u = (p - w/2.0)/(w/2.0)   # u ranges from -1 to 1\n        r = math.sqrt(u*u+v*v)   # The \"radius\"\n        if r > 1.0:\n            continue   # Consider only circle with r<1\n\n        theta = PI * r   # theta parameter of (i,j)\n        phi = math.atan2(v,u)   # phi parameter\n\n        x = math.sin(theta)*math.cos(phi)   #Cartesian components\n        y = math.sin(theta)*math.sin(phi)\n        z = math.cos(theta)\n\n        domega = (2*PI/w)*(2*PI/w)* sinc(theta)   # Computation of the solid angle\n\n        # Update the coefficients (i.e. compute the next term in the\n        # integral) based on the lighting value hdr\[3], the differential\n        # solid angle domega and cartesan components of surface normal x,y,z\n\n        for col in range (3):\n\n            # L_\{00\}. Note that Y_\{00\} = 0.282095\n            c = 0.282095\n            coeffs\[0]\[col] += hdr\[k]\[p]\[col]*c*domega\n\n            # L_\{1m\}. -1 <= m <= 1. The linear terms\n            c = 0.488603\n            coeffs\[1]\[col] += hdr\[k]\[p]\[col]*(c*y)*domega\n            coeffs\[2]\[col] += hdr\[k]\[p]\[col]*(c*z)*domega\n            coeffs\[3]\[col] += hdr\[k]\[p]\[col]*(c*x)*domega\n\n            # The Quadratic terms, L_\{2m\} -2 <= m <=2\n            \n            # First, L_\{2-2\}, L_\{2-1\}, L_\{21\} corresponding to xy, yz, xz\n            c = 1.092548\n            coeffs\[4]\[col] += hdr\[k]\[p]\[col]*(c*x*y)*domega\n            coeffs\[5]\[col] += hdr\[k]\[p]\[col]*(c*y*z)*domega\n            coeffs\[7]\[col] += hdr\[k]\[p]\[col]*(c*x*z)*domega\n\n            # L_\{20\}. Note that Y_\{20\} = 0.315392 (3z^2 - 1)\n            c = 0.315392\n            coeffs\[6]\[col] += hdr\[k]\[p]\[col]*(c*(3*z*z-1))*domega\n\n            # L_\{22\}. Note that Y_\{22\} = 0.546274 (x^2 - y^2)\n            c = 0.546274\n            coeffs\[8]\[col] += hdr\[k]\[p]\[col]*(c*(x*x-y*y))*domega\n\n# store the coefficients in the gizmo for rendering.\n\nmyNode\['L00'].setValue(\"%0.2f\" % float(coeffs\[0]\[0]/3.2))\nmyNode\['L00_1'].setValue(\"%0.2f\" % float(coeffs\[0]\[1]/3.2))\nmyNode\['L00_2'].setValue(\"%0.2f\" % float(coeffs\[0]\[2]/3.2))\n\nmyNode\['L1_1'].setValue(\"%0.2f\" % float(coeffs\[3]\[0]/3.2))\nmyNode\['L1_1_1'].setValue(\"%0.2f\" % float(coeffs\[3]\[1]/3.2))\nmyNode\['L1_1_2'].setValue(\"%0.2f\" % float(coeffs\[3]\[2]/3.2))\n\nmyNode\['L10'].setValue(\"%0.2f\" % float(coeffs\[2]\[0]/3.2))\nmyNode\['L10_1'].setValue(\"%0.2f\" % float(coeffs\[2]\[1]/3.2))\nmyNode\['L10_2'].setValue(\"%0.2f\" % float(coeffs\[2]\[2]/3.2))\n\nmyNode\['L11'].setValue(\"%0.2f\" % float(coeffs\[1]\[0]/3.2))\nmyNode\['L11_1'].setValue(\"%0.2f\" % float(coeffs\[1]\[1]/3.2))\nmyNode\['L11_2'].setValue(\"%0.2f\" % float(coeffs\[1]\[2]/3.2))\n\nmyNode\['L2_2'].setValue(\"%0.2f\" % float(coeffs\[4]\[0]/3.2))\nmyNode\['L2_2_1'].setValue(\"%0.2f\" % float(coeffs\[4]\[1]/3.2))\nmyNode\['L2_2_2'].setValue(\"%0.2f\" % float(coeffs\[4]\[2]/3.2))\n\nmyNode\['L2_1'].setValue(\"%0.2f\" % float(coeffs\[7]\[0]/3.2))\nmyNode\['L2_1_1'].setValue(\"%0.2f\" % float(coeffs\[7]\[1]/3.2))\nmyNode\['L2_1_2'].setValue(\"%0.2f\" % float(coeffs\[7]\[2]/3.2))\n\nmyNode\['L20'].setValue(\"%0.2f\" % float(coeffs\[6]\[0]/3.2))\nmyNode\['L20_1'].setValue(\"%0.2f\" % float(coeffs\[6]\[1]/3.2))\nmyNode\['L20_2'].setValue(\"%0.2f\" % float(coeffs\[6]\[2]/3.2))\n\nmyNode\['L21'].setValue(\"%0.2f\" % float(coeffs\[5]\[0]/3.2))\nmyNode\['L21_1'].setValue(\"%0.2f\" % float(coeffs\[5]\[1]/3.2))\nmyNode\['L21_2'].setValue(\"%0.2f\" % float(coeffs\[5]\[2]/3.2))\n\nmyNode\['L22'].setValue(\"%0.2f\" % float(coeffs\[8]\[0]/3.2))\nmyNode\['L22_1'].setValue(\"%0.2f\" % float(coeffs\[8]\[1]/3.2))\nmyNode\['L22_2'].setValue(\"%0.2f\" % float(coeffs\[8]\[2]/3.2))" +STARTLINE}
addUserKnob {26 DomeOrientation l "Dome Rotation"}
addUserKnob {7 X R -180 180}
addUserKnob {7 Y R -180 180}
addUserKnob {7 Z R -180 180}
addUserKnob {20 Red l INVISIBLE +INVISIBLE n 1}
addUserKnob {1 L00 l INVISIBLE -STARTLINE +INVISIBLE}
L00 0.00
addUserKnob {1 L1_1 l INVISIBLE -STARTLINE +INVISIBLE}
L1_1 0.00
addUserKnob {1 L10 l INVISIBLE -STARTLINE +INVISIBLE}
L10 0.00
addUserKnob {1 L11 l INVISIBLE -STARTLINE +INVISIBLE}
L11 -0.00
addUserKnob {1 L2_2 l INVISIBLE -STARTLINE +INVISIBLE}
L2_2 -0.00
addUserKnob {1 L2_1 l INVISIBLE -STARTLINE +INVISIBLE}
L2_1 -0.00
addUserKnob {1 L20 l INVISIBLE -STARTLINE +INVISIBLE}
L20 0.00
addUserKnob {1 L21 l INVISIBLE -STARTLINE +INVISIBLE}
L21 0.00
addUserKnob {1 L22 l INVISIBLE -STARTLINE +INVISIBLE}
L22 0.00
addUserKnob {20 endGroup n -1}
addUserKnob {20 Green l INVISIBLE +INVISIBLE n 1}
Green 0
addUserKnob {1 L00_1 l INVISIBLE -STARTLINE +INVISIBLE}
L00_1 0.00
addUserKnob {1 L1_1_1 l INVISIBLE -STARTLINE +INVISIBLE}
L1_1_1 0.00
addUserKnob {1 L10_1 l INVISIBLE -STARTLINE +INVISIBLE}
L10_1 0.00
addUserKnob {1 L11_1 l INVISIBLE -STARTLINE +INVISIBLE}
L11_1 0.00
addUserKnob {1 L2_2_1 l INVISIBLE -STARTLINE +INVISIBLE}
L2_2_1 0.00
addUserKnob {1 L2_1_1 l INVISIBLE -STARTLINE +INVISIBLE}
L2_1_1 0.00
addUserKnob {1 L20_1 l INVISIBLE -STARTLINE +INVISIBLE}
L20_1 0.00
addUserKnob {1 L21_1 l INVISIBLE -STARTLINE +INVISIBLE}
L21_1 0.00
addUserKnob {1 L22_1 l INVISIBLE -STARTLINE +INVISIBLE}
L22_1 0.00
addUserKnob {20 endGroup_1 l "" +STARTLINE n -1}
addUserKnob {20 Blue l INVISIBLE +INVISIBLE n 1}
Blue 0
addUserKnob {1 L00_2 l INVISIBLE -STARTLINE +INVISIBLE}
L00_2 0.00
addUserKnob {1 L1_1_2 l INVISIBLE -STARTLINE +INVISIBLE}
L1_1_2 0.00
addUserKnob {1 L10_2 l INVISIBLE -STARTLINE +INVISIBLE}
L10_2 0.00
addUserKnob {1 L11_2 l INVISIBLE -STARTLINE +INVISIBLE}
L11_2 0.00
addUserKnob {1 L2_2_2 l INVISIBLE -STARTLINE +INVISIBLE}
L2_2_2 0.00
addUserKnob {1 L2_1_2 l INVISIBLE -STARTLINE +INVISIBLE}
L2_1_2 0.00
addUserKnob {1 L20_2 l INVISIBLE -STARTLINE +INVISIBLE}
L20_2 0.00
addUserKnob {1 L21_2 l INVISIBLE -STARTLINE +INVISIBLE}
L21_2 0.00
addUserKnob {1 L22_2 l INVISIBLE -STARTLINE +INVISIBLE}
L22_2 0.00
addUserKnob {20 endGroup_2 l INVISIBLE +INVISIBLE n -1}
}
BackdropNode {
inputs 0
name ORIENTATION
tile_color 0x61806000
xpos 159
ypos 241
bdwidth 185
bdheight 152
}
Input {
inputs 0
name Normal
xpos 210
ypos 189
}
Expression {
temp_name0 inputZ
temp_expr0 parent.Z
temp_name1 sigma
temp_expr1 radians(inputZ)
expr0 cos(sigma)*r+sin(sigma)*g
expr1 -sin(sigma)*r+cos(sigma)*g
name ROT_Z
xpos 210
ypos 289
}
Expression {
temp_name0 inputX
temp_expr0 parent.X
temp_name1 theta
temp_expr1 radians(inputX)
expr1 cos(theta)*g+sin(theta)*b
expr2 -sin(theta)*g+cos(theta)*b
name ROT_X
xpos 210
ypos 314
}
Expression {
temp_name0 inputY
temp_expr0 parent.Y
temp_name1 epsilon
temp_expr1 radians(inputY)
expr0 cos(epsilon)*r-sin(epsilon)*b
expr2 sin(epsilon)*r+cos(epsilon)*b
name ROT_Y
xpos 210
ypos 339
}
Expression {
expr0 0.429043*parent.L22*(pow2(r)-pow2(g))+(0.743125*parent.L20*pow2(b))+0.886227*parent.L00-(0.247708*parent.L20)+2*0.429043*((parent.L2_2*r*g)+(parent.L21*r*b)+(parent.L2_1*g*b))+2*0.511664*((parent.L11*r)+(parent.L1_1*g)+(parent.L10*b))
expr1 0.429043*parent.L22_1*(pow2(r)-pow2(g))+(0.743125*parent.L20_1*pow2(b))+0.886227*parent.L00_1-(0.247708*parent.L20_1)+2*0.429043*((parent.L2_2_1*r*g)+(parent.L21_1*r*b)+(parent.L2_1_1*g*b))+2*0.511664*((parent.L11_1*r)+(parent.L1_1_1*g)+(parent.L10_1*b))
expr2 0.429043*parent.L22_2*(pow2(r)-pow2(g))+(0.743125*parent.L20_2*pow2(b))+0.886227*parent.L00_2-(0.247708*parent.L20_2)+2*0.429043*((parent.L2_2_2*r*g)+(parent.L21_2*r*b)+(parent.L2_1_2*g*b))+2*0.511664*((parent.L11_2*r)+(parent.L1_1_2*g)+(parent.L10_2*b))
expr3 a
name Irradiance_RENDERER
tile_color 0xc6595900
xpos 210
ypos 414
}
Clamp {
channels rgba
maximum_enable false
name CLAMP_BLACKS3
tile_color 0x7aa9ff00
xpos 210
ypos 464
}
Output {
name Output1
xpos 210
ypos 539
}
Input {
inputs 0
name LightProbe
xpos 385
ypos 189
number 1
}
Reformat {
format "256 256 0 0 256 256 1 square_256"
center false
name Reformat_IBL
xpos 385
ypos 307
}
end_group
